"""logic to patch the apex generated by SF to add extensions to the metadata class"""
import json

class ClassPatch:
    """This patch class patches the metadata apex generated by SF by adding extensions"""
    def __init__(self, metadata_extensions: str, input_file: str, output_file: str, api_version: str) -> None:
        self.input_file = input_file
        self.output_file = output_file
        self.api_version = api_version
        self.metadata_extensions = metadata_extensions
        self.metadata_extensions_dict = {}
        self.metadata_base_types = set()
        self.type_body_by_base_class = {}
        self.new_lines = []
        self.metadata_names = []

    def patch(self) -> None:
        """Method to patch the metadata class."""
        self.read_metadata_extensions()
        self.get_base_type_lines()
        self.patch_metadata_class()
        self.write_new_file()

    def read_metadata_extensions(self) -> None:
        """Method to read the metadata extensions file."""
        with open(self.metadata_extensions, encoding='utf-8') as json_file:
            self.metadata_extensions_dict = json.load(json_file)
            self.metadata_base_types = set(self.metadata_extensions_dict.values())

    def get_base_type_lines(self) -> None:
        """Method to get the base type lines."""
        with open(self.input_file, 'r', encoding='utf-8') as file:
            while True:
                line = file.readline()
                trimmed_line = line.strip()
                if 'public class' in trimmed_line:
                    parts = trimmed_line.split(' ')
                    class_name = parts[2]
                    if class_name in self.metadata_base_types:
                        base_type_lines = []
                        self.type_body_by_base_class[class_name] = base_type_lines
                        while True:
                            line = file.readline()
                            trimmed_line = line.strip()
                            if 'MetadataServiceImported' in trimmed_line:
                                line = line.replace('MetadataServiceImported', 'MetadataService')
                            base_type_lines.append(line)
                            if 'private String[] field_order_type_info' in trimmed_line:
                                break
                if not line:
                    break

    def patch_metadata_class(self) -> None:
        """Method to patch the metadata class."""
        with open(self.input_file, 'r', encoding='utf-8') as f:
            while True:
                line = f.readline()
                trimmed_line = line.strip()
                if 'MetadataServiceImported' in trimmed_line:
                    line = line.replace('MetadataServiceImported', 'MetadataService')
                if 'public String endpoint_x' in trimmed_line:
                    line = '        public String endpoint_x = URL.getOrgDomainUrl().toExternalForm() + \'/services/Soap/m/' + self.api_version + '\';\n';
                elif 'update_x' in trimmed_line:
                    line = line.replace('update_x', 'updateMetadata')
                elif 'delete_x' in trimmed_line:
                    line = line.replace('delete_x', 'deleteMetadata')
                elif 'retrieve_x' in trimmed_line:
                    line = line.replace('retrieve_x', 'retrieve')
                elif 'public class Metadata ' in trimmed_line:
                    line = line.replace('public class', 'public virtual class')
                    self.new_lines.append(line)
                    while True:
                        line = f.readline()
                        trimmed_line = line.strip();
                        #  Skip these, not needed as duplciated in derived classes and cause JSON serialise issues for types
                        if 'fullName_type_info' in trimmed_line or 'apex_schema_type_info' in trimmed_line or 'field_order_type_info' in trimmed_line:
                            continue
                        if 'MetadataServiceImported' in trimmed_line:
                            line = line.replace('MetadataServiceImported', 'MetadataService')
                        self.new_lines.append(line)
                        if trimmed_line == '}':
                            break
                    continue
                elif trimmed_line.startswith('public class ReadResult'):
                    self.new_lines.append('    public interface IReadResult {\n')
                    self.new_lines.append('        MetadataService.Metadata[] getRecords();\n')
                    self.new_lines.append('    }\n')
                    self.new_lines.append('    public interface IReadResponseElement {\n')
                    self.new_lines.append('        IReadResult getResult();\n')
                    self.new_lines.append('    }\n')
                elif trimmed_line.startswith(
                        'public MetadataServiceImported.ReadResult readMetadata(String type_x,String[] fullNames) {'):
                    while True:
                        line = f.readline()
                        trimmed_line = line.strip()
                        if '}' == trimmed_line:
                            break
                    self.new_lines.append(
                        '        public MetadataService.IReadResult readMetadata(String type_x,String[] fullNames) {\n')
                    self.new_lines.append(
                        '            MetadataService.readMetadata_element request_x = new MetadataService.readMetadata_element();\n')
                    self.new_lines.append('            request_x.type_x = type_x;\n')
                    self.new_lines.append('            request_x.fullNames = fullNames;\n')
                    self.new_lines.append('            MetadataService.IReadResponseElement response_x;\n')
                    self.new_lines.append(
                        '            Map<String, MetadataService.IReadResponseElement> response_map_x = new Map<String, MetadataService.IReadResponseElement>();\n')
                    self.new_lines.append('            response_map_x.put(\'response_x\', response_x);\n')
                    self.new_lines.append('            WebServiceCallout.invoke(\n')
                    self.new_lines.append('              this,\n')
                    self.new_lines.append('              request_x,\n')
                    self.new_lines.append('              response_map_x,\n')
                    self.new_lines.append('              new String[]{endpoint_x,\n')
                    self.new_lines.append('              \'\',\n')
                    self.new_lines.append('              \'http://soap.sforce.com/2006/04/metadata\',\n')
                    self.new_lines.append('              \'readMetadata\',\n')
                    self.new_lines.append('              \'http://soap.sforce.com/2006/04/metadata\',\n')
                    self.new_lines.append('              \'readMetadataResponse\',\n')
                    self.new_lines.append('              \'MetadataService.read\' + type_x + \'Response_element\'}\n')
                    self.new_lines.append('            );\n')
                    self.new_lines.append('            response_x = response_map_x.get(\'response_x\');\n')
                    self.new_lines.append('            return response_x.getResult();\n')
                # adjust extention class
                elif 'public class' in trimmed_line:
                    parts = trimmed_line.split(' ')
                    class_name = parts[2]
                    if class_name in self.metadata_base_types:
                        if class_name in self.metadata_extensions_dict.keys():
                            line = line.replace('public class ' + class_name,
                                                'public virtual class ' + class_name + ' extends ' +
                                                self.metadata_extensions_dict[
                                                    class_name])
                        else:
                            line = line.replace('public class ' + class_name, 'public virtual class ' + class_name)
                        self.new_lines.append(line)
                        while True:
                            line = f.readline()
                            trimmed_line = line.strip();
                            #  Skip these, not needed as duplciated in derived classes and cause JSON serialise issues for types
                            if 'private String[]' in trimmed_line:
                                continue
                            if 'MetadataServiceImported' in trimmed_line:
                                line = line.replace('MetadataServiceImported', 'MetadataService')
                            self.new_lines.append(line)
                            if trimmed_line == '}':
                                break
                        continue
                    # Adjust class to extend base class and add base class members (XML serialiser does not support inheritance)
                    elif class_name in self.metadata_extensions_dict.keys():
                        # record all the metadata class names to generate IRead method
                        self.metadata_names.append(class_name)
                        line = line.replace('public class ' + class_name,
                                            'public class ' + class_name + ' extends ' + self.metadata_extensions_dict[
                                                class_name])
                        self.new_lines.append(line)
                        self.new_lines.append('        public String type = \'' + class_name + '\';\n');
                        # Keep going all the way down to the last base class
                        # have a better variable name for this
                        base_type_field_order_info = []
                        base_types = []
                        baseclass_name = self.metadata_extensions_dict[class_name]
                        while baseclass_name is not None:
                            base_types.append(baseclass_name)
                            if baseclass_name in self.metadata_extensions_dict.keys():
                                baseclass_name = self.metadata_extensions_dict[baseclass_name]
                            else:
                                break
                        # print(base_types)
                        for baseclass_name in base_types:
                            if baseclass_name in self.type_body_by_base_class.keys():
                                base_class_lines = self.type_body_by_base_class[baseclass_name]
                                for base_class_line in base_class_lines:
                                    # Skip this base class member as the top level derived type will have one
                                    if 'apex_schema_type_info' in base_class_line:
                                        continue
                                    # Extract the field order type info list to add to the derived type one
                                    if 'field_order_type_info' in base_class_line:
                                        # Extract the list of base type fields
                                        if base_class_line.find("'") > 0:
                                            base_type_field_order_info.append(
                                                base_class_line[base_class_line.index(
                                                    "'"): base_class_line.rindex("'") + 1])
                                        # Skip it as the top level derived type will have one
                                        continue
                                    self.new_lines.append(base_class_line)
                        while True:
                            line = f.readline()
                            trimmed_line = line.strip()
                            if 'MetadataServiceImported' in trimmed_line:
                                line = line.replace('MetadataServiceImported', 'MetadataService')
                            # Adjust the fields listed in the field_order_type_info metadata
                            if trimmed_line.startswith('private String[] field_order_type_info'):
                                # Add type info descriptors and adjust field_order_type_info list
                                self.new_lines.append(
                                    '        private String[] type_att_info = new String[]{\'xsi:type\'};\n')
                                new_field_order_type = ', '.join(base_type_field_order_info) if len(
                                    base_type_field_order_info) > 0 else ''
                                if line.endswith('new String[]{};'):
                                    line = line.replace('new String[]{', 'new String[]{' + new_field_order_type)
                                else:
                                    line = line.replace('new String[]{', 'new String[]{' + new_field_order_type + ', ')
                                self.new_lines.append(line)
                                break
                            self.new_lines.append(line)
                        continue
                self.new_lines.append(line)
                if not line:
                    # remove the last curly bracket to add inner IRead classes in
                    last_item = self.new_lines.pop()
                    while last_item != '}':
                        last_item = self.new_lines.pop()
                    for class_name in self.metadata_names:
                        base_class = self.metadata_extensions_dict[class_name]
                        while base_class is not None:
                            if base_class == 'Metadata' or base_class == 'MetadataWithContent' or base_class == 'FlowBaseElement':
                                break
                            base_class = self.metadata_extensions_dict[base_class]
                        if base_class == 'Metadata' or base_class == 'MetadataWithContent':
                            apex_class_type = class_name
                            if class_name == 'Group_x':
                                apex_class_type = 'Group'
                            elif class_name == 'Package_x':
                                apex_class_type = 'Package'
                            self.new_lines.append(
                                '    public class Read' + apex_class_type + 'Result implements IReadResult {\n')
                            self.new_lines.append('        public MetadataService.' + class_name + '[] records;\n')
                            self.new_lines.append(
                                '        public MetadataService.Metadata[] getRecords() { return records; }\n')
                            self.new_lines.append(
                                '        private String[] records_type_info = new String[]{\'records\',\'http://soap.sforce.com/2006/04/metadata\',null,\'0\',\'-1\',\'false\'};\n')
                            self.new_lines.append(
                                '        private String[] apex_schema_type_info = new String[]{\'http://soap.sforce.com/2006/04/metadata\',\'true\',\'false\'};\n')
                            self.new_lines.append(
                                '        private String[] field_order_type_info = new String[]{\'records\'};\n')
                            self.new_lines.append('    }\n')
                            self.new_lines.append(
                                '    public class read' + apex_class_type + 'Response_element implements IReadResponseElement {\n')
                            self.new_lines.append(
                                '        public MetadataService.Read' + apex_class_type + 'Result result;\n')
                            self.new_lines.append('        public IReadResult getResult() { return result; }\n')
                            self.new_lines.append(
                                '        private String[] result_type_info = new String[]{\'result\',\'http://soap.sforce.com/2006/04/metadata\',null,\'1\',\'1\',\'false\'};\n')
                            self.new_lines.append(
                                '        private String[] apex_schema_type_info = new String[]{\'http://soap.sforce.com/2006/04/metadata\',\'true\',\'false\'};\n')
                            self.new_lines.append(
                                '        private String[] field_order_type_info = new String[]{\'result\'};\n')
                            self.new_lines.append('    }\n')
                    self.new_lines.append('}')
                    break

    def write_new_file(self) -> None:
        with open(self.output_file, 'w') as f:
            f.write('/**\n')
            f.write(' * Copyright (c), FinancialForce.com, inc\n')
            f.write(' * All rights reserved.\n')
            f.write(' *\n')
            f.write(' * Redistribution and use in source and binary forms, with or without modification,\n')
            f.write(' *   are permitted provided that the following conditions are met:\n')
            f.write(' *\n')
            f.write(' * - Redistributions of source code must retain the above copyright notice,\n')
            f.write(' *      this list of conditions and the following disclaimer.\n')
            f.write(' * - Redistributions in binary form must reproduce the above copyright notice,\n')
            f.write(' *      this list of conditions and the following disclaimer in the documentation\n')
            f.write(' *      and/or other materials provided with the distribution.\n')
            f.write(' * - Neither the name of the FinancialForce.com, inc nor the names of its contributors\n')
            f.write(' *      may be used to endorse or promote products derived from this software without\n')
            f.write(' *      specific prior written permission.\n')
            f.write(' *\n')
            f.write(' * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n')
            f.write(
                ' *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n')
            f.write(
                ' *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\n')
            f.write(
                ' *  THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n')
            f.write(
                ' *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n')
            f.write(
                ' *  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n')
            f.write(
                ' *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n')
            f.write(
                ' *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n')
            f.write('**/\n')
            for line in self.new_lines:
                f.write(line)
